\documentclass{article}

\usepackage[italian]{babel}
\usepackage{blindtext}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{mathtools}
\usepackage{listings}
\usepackage[dvipsnames]{xcolor}
\usepackage[normalem]{ulem}
\usepackage{listings}
\usepackage[export]{adjustbox}
\usepackage{lscape}
\usepackage{float}
\usepackage{booktabs}

%% \usepackage{pdftricks}
%% \begin{psinputs}
%%   \usepackage{pstricks}
%% \end{psinputs}
%% \usepackage[pdf]{pstricks}

\usepackage{float}
\usepackage[hypertexnames=false]{hyperref}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\floatname{algorithm}{Pseudocode}

\usepackage{cleveref}
\usepackage{tikz}
\usetikzlibrary{matrix,shapes,arrows,positioning,chains}
\usepackage{hhline}
\usepackage{multirow}

\pagestyle{plain}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\include{macro}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
%
\section{Il problema}
Ricerca di un sottografo etichettato (o parzialmente etichettato)
all'interno di un grafo prefissato, tramite algoritmo distribuito
basato su conoscenze frammentarie del grafo complessivo
accumulate da sensori, con limitate capacit\`a di memorizzazione
e di ampiezza di segnale.
%
%
\subsection{Formalizzazione}
Dato un grafo $\cG = ( \Vset, E)$, $\Vset = \{v_i\}_{i \in V}$,
\textbf{fisso}, viene inizializzato un insieme di processi
$\Pset = \{p_i \}_{i \in P}$ con $P$ insieme random $P \sseq V$.
I processi simulano i sensori sparpagliati nella rete:
acquisiscono durante la fase di inizializzazione una conoscenza
parziale del grafo $\cG$: ogni $p_i$ memorizza l'intera lista di adiacenza
del nodo corrispondente $v_i$.
Inizialmente dunque il raggio di conoscenza di ogni sensore \`e
di un solo arco in avanti del grafo.
(\textbf{Simuliamo} questo comportamento caricando i dati da una mappa
centralizzata.)

La query $\cQ = (\Vset_\cQ, E_\cQ)$ viene divulgata (~\ref{sec:scelte})
alla rete di processi.
I nodi in $\Vset_\cQ$ sono etichettati (~\ref{sec:scelte}),
cos\`i che ogni sensore possa verificare l'appartenenza alla query
dei nodi di cui \`e a conoscenza.
Conseguentemente pu\`o propagare una nuova query ``snellita'' agli altri
processi per proseguire nella ricerca del match completo.

Quando un processo riesce a completare il match di tutta la query proposta,
pu\`o comunicare la riuscita dell'algoritmo.

Quando nessuna ipotesi \`e in circolazione la ricerca termina.

\section{Da decidere}
\label{sec:scelte}
\begin{itemize}
\item Modello fisico:
  Pu\`o essere utile fornire un modello fisico di riferimento da cui
  trarre le ipotesi del nostro approccio.
  \begin{itemize}
  \item Telecamere statiche. Variabilit\`a solo nell'aggiunta di nuovi
    sensori, possibilit\`a di ``conoscere'' la posizione degli altri..

    \coanote{Anna: non mi sembra tanto distribuita come opzione..}
  \item Sensori sparpagliati. Ha senso pensare che si possano muovere
    e accrescere la loro conoscenza. Non dovrebbero avere alcuna info
    sulla posizione degli altri sensori. \`E ammesso che pi\`u sensori
    condividano in un momento la stessa posizione (i.e. non c'\`e
    conflitto sui nodi in cui sono posizionati).
  \item ... some other clever option ...
  \end{itemize}
\item Struttura della query:
  \begin{itemize}
    \item La query pu\`o arrivare interamente etichettata: rende la ricerca
      pi\`u facile (un nodo pu\`o accorgersi subito di non avere match e
      in caso di riuscita, \textbf{non} \`e necessario restituire il
      sottografo trovato).
    \item Ci possono essere dei nodi ``jolly'' la cui
      istanziazione viene lasciata al processo che procede nell'elaborare
      l'ipotesi. Questo comporta dover propagare, insieme alla nuova query
      snellita, l'elenco delle variabili istanziate.
      Alla fine il match viene comunicato con all'insieme degli assegnamenti
      che consente di trovare il sottografo.

      \coanote{Anna: A chi viene comunicata? In che forma?
      Controllare di non restituire pi\`u volte la stessa soluzione?}
    \item (very difficoult) Dare solo nodi di passaggio senza pretendere
      per quanti nodi intermedi deve passare il sottografo. Corrisponde
      al dover trovare un percorso che passi (per alcuni punti).
      Aumenterebbe molto la dimensione del messaggio perch\'e con
      l'ipotesi bisogna passare anche l'attuale insieme dei nodi
      attraversati; inoltre siamo (sempre?) costretti ad esplorare
      tutto il grafo in cerca di altri percorsi.

      \coanote{Anna: (Se vuoi il mio parere, io questa la segherei subito.)}
  \end{itemize}
\item Modello di failure:%
  ~\href{https://doc.akka.io/docs/akka/2.5/fault-tolerance.html}{akka-doc}
  \begin{itemize}
  \item Top-Level Supervisor: sarebbe anche il padre di tutti
    i processi, che innesca la fase di inizializzazione. Se un figlio
    muore, \`e incaricato di ricrearlo (nella stessa posizione? o in una
    nuovamente random?) reinizializzando la sua memoria: i.e. quello che
    il sensore morto ha imparato nel frattempo viene perso.
    Il supervisor viene a sua volta monitorato da un supervisor del
    sistema di Akka: occorre specificare che non vogliamo che la sua
    morte causi la morte di tutti i figli.

    \coanote{Anna: \`E comunque realistico pensare di avere un
      ``coordinatore''? Possiamo davvero evitare di dover aggiungere
      algoritmi di elezione?}
  \item One-to-one supervisor: pi\`u pesante? Non sfrutta funzionalit\`a
    gi\`a offerte da Akka? Il ``coordinatore'', comunque necessario per
    decidere il fallimento della query da parte di tutte le componenti,
    andrebbe deciso tramite algoritmo di elezione.
  \end{itemize}
\item Comunicazione sensori:
  \begin{itemize}
  \item Multicast: non ho bisogno di sapere dove sono gli altri sensori,
    divulgo a tutti la mia attuale ipotesi.
  \item One-to-one: occorre che i sensori conoscano la posizione
    degli altri: in fase di inizializzazione marcano i nodi che sanno
    occupati. \coanote{Anna: location transparency sta ceppa..?}
    Poter sapere a chi comunicare permette uno scambio molto limitato di
    messaggi, ma limita la potenza dell'algoritmo: e.g. se due sensori
    sono a distanza $r+1$ con $r$ raggio di visuale, non si vedono
    direttamente, dunque non riuscirebbero a completare una query che
    \`e sottografo della rete data dalla somma delle conoscenze.
  \item Pub-Sub: ogni nodo del grafo (alternativamente, si divide a priori
    il grafo in regioni) ha una propria coda di messaggi.
    Quando si propaga un'ipotesi, la si manda nella coda di messaggi dei
    nodi che mancano da verificare.
    (questo faciliterebbe tra l'altro la prima divulgazione della query)
    I sensori sono in ascolto sulle code dei nodi (/ della regione)
    che conoscono.
    In questo modo si aumenta la capacit\`a di riconoscimento
    dell'algoritmo, pur evitando una comunicazione multicast con
    scambio di messaggi inutili.

    \coanote{Anna: quando un processo legge dalla coda, consuma il messaggio?
      In realt\`a pi\`u altri sensori potrebbero essere interessati allo
      stesso messaggio, ma allora, se non vengono rimossi in lettura,
      chi svuota le code??? \`E un'implementazione offerta da Akka?}
    \coanote{Anna: assumendo che le code vengano mano a mano svuotate dopo
      essere state lette da tutti gli interessati,
      il test di terminazione della ricerca pu\`o essere fatto controllado
      la capacit\`a delle varie code? In teoria,
      se nessuna coda ha ipotesi in circolazione, tutti i nodi hanno fallito.
      \`E un test troppo pesante da fare?}
    \coanote{Anna: \`e un'implementazione che pu\`o vantare di essere
      scalabile?}

    \href{https://doc.akka.io/docs/akka/2.5/distributed-pub-sub.html}
    {akka-doc}
  \end{itemize}
\item Quando la ricerca fallisce possiamo ritentare una \textbf{nuova} query
  (i.e. si ricomincia da capo senza avere info accumulate dalla precedente
  ricerca fallita) dopo aver aumentanto la conoscenza attuale del grafo:
  \begin{itemize}
  \item muovendo i sensori: ogni sensore si sposta di un passo in uno
    dei suoi figli, scelto non deterministicamente, e aumeta la propria
    conoscenza caricando dalla mappa la lista di adiacenza del nuovo nodo.

    Dobbiamo porre un limite alla conscenza che ogni nodo pu\`o
    accumulare.
  \item aggiungendo random un nuovo sensore nella rete
    (eventualmente dopo aver provato un numero prefissato di volte il
    movimento dei sensori).
  \end{itemize}
\end{itemize}
%
\end{document}
