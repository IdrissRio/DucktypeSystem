\documentclass{llncs}

\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}
%% \usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage{blindtext}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{mathtools}
\usepackage{listings}
\usepackage[dvipsnames]{xcolor}
\usepackage[normalem]{ulem}
\usepackage{listings}
\usepackage[export]{adjustbox}
\usepackage{lscape}
\usepackage{float}
\usepackage{booktabs}

%% \usepackage{pdftricks}
%% \begin{psinputs}
%%   \usepackage{pstricks}
%% \end{psinputs}
%% \usepackage[pdf]{pstricks}

\usepackage{float}
\usepackage[hypertexnames=false]{hyperref}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\floatname{algorithm}{Pseudocode}

\usepackage{cleveref}
\usepackage{tikz}
\usetikzlibrary{matrix,shapes,arrows,positioning,chains}
\usepackage{hhline}
\usepackage{multirow}

\pagestyle{plain}

%%%%
\include{macro}
%%%%
\subtitle{A distribuited algorithm\\for the subgraph isomorphism problem}
\title{Analisi dei requisiti}
\author{Anna Becchi, Idriss Riouak}
\institute{Laurea Magistrale in Informatica\\Universit\`a di Udine, Italy}
\date{A.A. 2017/2018}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

%\begin{titlingpage}
\maketitle
\begin{abstract}
In letteratura il problema del \emph{subgraph isomorphism}
centralizzato è stato ampiamente studiato. Ciononostante è difficile
trovare studi relativi alla stessa problematica su sistemi distribuiti.
L'obiettivo della seguente analisi è fornire un algoritmo distribuito
per il \emph{subgraph isomorphism} individuandone le criticità e
problematiche, descrivendo dunque i requisiti funzionali e non
funzionali del sistema come ad esempio la \emph{tolleranza ai
guasti} e \emph{consistenza} delle strutture dati. 
\end{abstract}
%\end{titlingpage}

\section{Introduzione}
Il \emph{subgraph isomorphism} ha diverse applicazioni nello contesto
dei sistemi distribuiti, in particolare considereremo il caso in cui  un insieme
di \emph{robot} con \emph{sensori wireless} viene posizionato all'interno di
un edificio in maniera casuale. Tali robot hanno una visione parziale dell'edificio
e sono in grado di comunicare unicamente attraverso scambio di messaggi.
Dunque dato un percorso l'obiettivo finale è quello di determinare se esiste
solamente attraverso la conoscenza parziale dei robot.

\subsection{Modellazione del problema}
Dato un grafo $\cG = ( \Vset, E)$, $\Vset = \{v_i\}_{i \in V}$,
che rappresenta la mappa di un edificio, viene inizializzato un
insieme di processi $\Sset = \{s_i \}_{i \in S}$ con $S$ insieme
random $S \sseq V$.
Tali processi simulano l'insieme dei robot che
acquisiscono, durante la fase di inizializzazione, una conoscenza
parziale del luogo. L'acquisizione di nuova conoscenza corrisponde
alla memorizzazione in ogni $s_i$ della lista di adiacenza del nodo
corrispondente $v_i \in \Vset$.
Inizialmente dunque il raggio di conoscenza di ogni sensore corrisponde
a un solo arco del grafo.

Inoltre potrà essere simulato anche il loro spostamento e la progressiva
acquisizione di nuova conoscenza del grafo, compatibilmente con le
loro (limitate) capacità di memorizzazione.

L'algoritmo viene innescato da una query $\cQ = (\Vset_\cQ, E_\cQ)$, 
che viene divulgata alla rete di processi: l'obiettivo sarà verificare
nel grafo $\cG$ l'esistenza di un sottografo corrispondente a $\cQ$,
evitando di ricostruire la conoscenza totale e centralizzata del
grafo stesso.

Considereremo black-box tutti gli aspetti legati all'acquisizione delle informazioni 
da parte dei robot, focalizzando l'attenzione sull'astrazione matematica.



\subsection{Ambiente di sviluppo}
L'ambiente di sviluppo è stato scelto in modo tale da poter evidenziare solamente
le caratteristiche più rilevanti del problema. 
Si è scelto di utilizzare il \emph{Akka}: un toolkit per la creazione di applicazioni 
distribuite e concorrenti con supporto alla \emph{fault-tollerance event-driven}.
Il toolkit è disponibile sia per il linguaggio imperativo \emph{Java} che per il 
funzionale \emph{Scala}.

Akka si basa sulla figura degli \emph{Actor}. Un Actor è un astrazione che permette
al programmatore di focalizzare l'attenzione sugli obiettivi funzionali liberandolo 
da alcune di quelle che sono le  problematiche della programmazione 
concorrente e distribuita tra cui: gestione dei thread e creazioni di canali.

\section{Requisiti funzionali}
\label{sec:func-req}


Si assume la memorizzazione pregressa del grafo $\cG = ( \Vset, E)$, $\Vset = \{v_i\}_{i \in V}$.
Questo potrà essere letto da un file esterno e caricato dal sistema
staticamente, così come la query. Si assume inoltre che i grafi vengano forniti
sotto forma di liste d'adiacenza.
Non sarà dunque possibile cambiare a runtime la mappa
del luogo nel quale i sensori lavorano.


Sia $\Sset = \{s_i \}_{i \in S}$ l'insieme dei processi con $S$ insieme random $S \sseq V$.
L'utente può decidere in fase di inizializzazione del sistema con quanti
sensori popolare la mappa ovvero l'utente determina $|S|$.
 Questi verranno distribuiti in modo casuale
ognuno in corrispondenza di un nodo del grafo: è ammesso che più
sensori condividano in un momento la stessa posizione
(i.e. non c'è conflitto sui nodi in cui sono posizionati). 

L'utente inoltre fornirà in input un intero $k$, se non definito il valore di  default 
viene posto a 3, che rappresenterà il numero di  \emph{Search\_Group} creati ovvero il livello
di replicazione del sistema \ref{sec:nonfunc-req}. 

Se la query non viene trovata, l'utente può decidere se ritentare
la stessa ricerca dopo aver fatto acquisire nuova conoscenza al sistema
distribuito: ciò può essere fatto in due modi.
Si può aggiungere un nuovo sensore alla rete, posizionato in modo
casuale nel grafo. Alternativamente
si possono far muovere \emph{tutti} i sensori in un loro nodo adiacente,
scelto non deterministicamente, caricando dal grafo (centralizzato)
la lista di adiacenza del nuovo nodo: ciò simula quindi una fase di
\emph{apprendimento} da parte di ogni sensore. Occorre tenere presente
che i sensori hanno una capacità limitata di memorizzazione,
dunque si permetterà di mantenere contemporaneamente in memoria un
numero limitato di nodi: può dunque accadere che durante il movimento
vengano scordate le liste di adiacenza dei nodi più lontani.
\coanote{TODO: definire capacità massima.}\\

In caso in cui venga trovato un sottografo corrispondente alla query,
questo viene comunicato all'utente.
Oltre alla mera conferma della sua esistenza, vengono aggiunte
le eventuali istanziazioni dei nodi non etichettati.
Sebbene la stessa soluzione possa essere trovata da più sensori,
la sua restituzione sarà unica, in particoalre si eviterà di rispondere
positivamente più volte per confermare l'esistenza di un sottografo
interamente etichettato.\\

\coanote{TODO: definire già interfacce e nomi metodi??
  Almeno fornire sottoforma di elendo il nome del metodo, senza ancora
  specificare parametri e tipo parametri...
}

\subsection{Ruoli}
In questa sezione descriviamo le caratteristiche e le funzionalità
efferte dai principali ruoli del sistema:
oltre ai sensori, che costituiscono la parte distribuita
è necessario definire a priori alcuni ruoli centralizzati
che possano essere punto di accesso all'intero cluster.%
~\footnote{Come verrà successivamente analizzato,
  nella Sezione~\ref{sec:nonfunc-req} questo non lede alla
  scalabilità del sistema.}

\subsubsection*{Sensore}
I sensori vengono sparpagliati in fase di inizializzazione del
sistema ognuno su un nodo della rete: sono in grado di
acquisire una conoscenza parziale del grafo, assumendo che si
riesca sempre ad acquisire correttamente tutta l'informazione
locale al nodo su cui si trovano
(tale fase di acquisizione verrà simultata tramite il caricamento
della lista di adiacenza di alcuni nodi da un grafo centralizzato,
astraendo l'implementazione dai particolari metodi di
rilevazione e di sintesi delle informazioni).

Sono in grado di muoversi e di conseguenza aumentare la loro
conoscenza.

Data la loro limitata capacità di memorizzazione,
stimata essere \coanote{``STIMAMI!!''},
può accadere che
durante uno spostamento perdano conoscenza rispetto alla zona del
grafo precedentemente esplorata.

Rispetto ad un'analisi ad alto livello,
saranno in grado di gestire messaggi del tipo:
\begin{itemize}
\item \texttt{try-query()}: alla ricezione della query da verificare
  si occupa di rimuovere da questa le parti che corrispondono alla
  sua conoscenza parziale del grafo. In questa fase può riuscire a
  verificare la presenza dell'intera query (\emph{match}),
  scoprire inconsistenze della query con il grafo conosciuto
  (\emph{fail}), oppure rimanere in una fase di \emph{dontknow}
  per cui rimangono elementi ancora da verificare: la nuova query
  prodotta verrà rimandata al resto del cluster attivo.
  Al termine il sensore si dichiarerà non più interessato a seguire
  gli sviluppi di quella query, avendo già contribuito con le
  sue conoscenze.
\item \texttt{move()}: causa lo spostamento del sensore e il
  conseguente caricamento di nuova conoscenza.
\end{itemize}

\subsubsection*{Accesso al cluster}
Definiamo alcuni ruoli di accesso all'intero cluster di sensori
che si occuperanno di:
\begin{itemize}
\item inizializzare il sistema distribuendo random i sensori sui
  nodi del grafo totale;
\item distribuire la richiesta di spostamento a tutti i sensori;
\item aggiungere un nuovo sensore sulla mappa;
\item iniziare una nuova ricerca;
\item forzare la terminazione della ricerca.
\end{itemize}

\subsubsection*{Interfaccia}
L'interfaccia con l'utente viene fornita da terminale, offrendo:
\begin{itemize}
\item comando caricare manualmente la mappa del grafo
  completo (utile in fase di sperimentazione);
\item comando per iniziare una nuova query caricandola da file:
  la query verrà controllata perché non può richiedere una
  memorizzazione superiore alla capacità di un singolo sensore.
\item comando per imporre l'avanzamento di tutti i sensori;
\item comando per l'aggiunta manuale di un nuovo sensore;
\item restituizione del risultato (\emph{match}, \emph{fail},
  \emph{dontknow}) all'utente.
\end{itemize}

\section{Requisiti non funzionali}
\label{sec:nonfunc-req}
\begin{quote}
  Everything about mode and transparencies:
  availability, mobility, security, fault tolerance, etc.
  Are there execution time bounds? Minimum data rates?

  If requested, specific platforms/languages/middlewares requirements
  for the implementation can be decided here.
  (E.g.: if the project is on a SOA, we may request that functions
  are offered via SOAP or RESTful services).
\end{quote}

In questa sezione analizziamo le caratteristiche non funzionali
che il sistema sarà in grado di offrire.

\subsubsection*{Scalabilità e trasparenza}
I sensori costituiscono una rete peer-to-peer,
senza alcuna suddivisione di ruoli a priori: i ruoli centralizzati
sono definiti staticamente con il compito fissato di fornire un punto
di accesso al cluster in ingresso (proponendo una nuova query) e
in uscita (raccogliendo informazioni relative alla riuscita
o fallimento della query).

La \emph{conoscenza} del grafo complessivo è totalmente distribuita:
non viene ricostruita alcuna conoscenza centralizzata di essa.
Questo rende il sistema scalabile e flessibile:
si possono dinamicamente aggiungere nuovi sensori o far spostare
quelli già presenti nella rete, senza dover riconfigurare nulla.
L'implementazione delle
comunicazioni tra i punti di accesso centrali al cluster e
tra gli elementi stessi scalano con la dimensione del cluster:
inoltre il sistema risulta svincolato dal conoscere la posizione
dei singoli sensori: il grado di \emph{location transparency} offerto
è dunque molto elevato.

Il sistema è inoltre \emph{flessibile}: quando nuovi sensori vengono
aggiunti, o quando si muovono quelli già presenti, si acquisisce
nuova conoscenza che sarà utilizzabile dalle query successive.

\subsubsection*{Load balancing}
La risoluzione del problema e la ricostruzione del sottografo
comporta l'esplorazione progressiva e necessariamente sequenziale
dei sensori che hanno informazioni rilevanti per la query.
Non potendo dunque essere sfruttato in ogni caso il parallelismo
offerto da un sistema distribuito, non risulta una limitazione
in termini di efficienza avere un solo nodo attivo alla volta.
%% Inoltre,
%% il percorso di esplorazione della query, progressivamente snellita,
%% non influisce nella sua determinazione: una qualunque delle n! possibili
%% permutazioni -- qualunque sia l'ordine in cui la query attraversa i nodi --
%% trova la stessa soluzione, che richiede l'intervento SEQUENZIALE di
%% tutti i nodi che possono dire qualcosa sulla query stessa.
%% Dunque, dal punto di vista della correttezza dell'algoritmo,
%% a meno di failure, possiamo far procedere una sola query alla volta.

\subsubsection*{Failure model}
Trattandosi di query potenzialmente molto lunghe da verificare,
comunque da gestirsi in modo sequenziale in un numero potenzialmente
alto di sensori,
siamo disposti ad aggiungere messaggi informativi che ci consentano,
in caso di fallimenti durante la ricerca di recuperare la query parziale,
evitando di perdere il lavoro eseguito fino a quel momento.

In quanto stiamo lavorando in un contesto distribuito,
occorre tenere in considerazione i fallimenti legati alla rete e i
fallimenti legati ai sensori stessi.

Per proteggersi dalla perdita da parte della rete dei messaggi
con i quali si divulga la query durante una ricerca,
il mittente aspetterà un messaggio di \emph{acknowledgement}: questo
comporta dover definire un timeout di attesa massima prima di
stabilire che il messaggio è andato perduto e dunque che è necessario
reinviarlo. Tale soluzione è comunque affetta a casi di duplice invio
della stessa query, nel caso sia il messaggio di \emph{ack} ad
essere perso dalla rete.

Per proteggersi da casi di fallimento e morte dei sensori,
si utilizzerà un sistema di supervisione \emph{one-to-one}
per cui ogni processo sensore ha un supervisore in grado di
riattivarlo e di reiscrivero al cluster.
La ricerca può essere intaccata da fallimenti di questo tipo
quando il sensore muore nel momento in cui sta elaborando
nuove ipotesi sulla query attiva.
Copiare una versione della query parziale nel supervisore del nodo,
limita la finestra temporale in cui può accadere questo fallimento
critico.
Possiamo ulteriormente proteggere il sistema facendo procedere
un numero $k$ costante (\coanote{3 di default???}) di query
contemporaneamente. Questa ridondanza introdotta, come già discusso,
non può essere una forma di parallelizzazione del lavoro: avere
più ricerche attive nello stesso momento permette unicamente di
avere più possibilità che una di queste giunga all'esplorazione
di tutto lo spazio dei sensori senza incontrare i fallimenti critici
ai quali il sistema rimane soggetto.
Questi ultimi infatti, hanno nel caso pessimo l'effetto di
rendere la corrispondente ricerca inattiva: quando una delle versioni
arriva alla conclusione, sblocca quelle che eventualmente sono rimaste
bloccate in questo stato.

Nel malaugurato caso in cui tutte le ricerche incontrino fallimenti
critici (ovvero quelli che avvengono in porzioni già molto limitate
del codice), il sistema risulta bloccato: pur non potendo
distinguere tale sospensione dalla fase di ricerca, si affida
la responsabilità all'utente di terminare la ricerca manualmente.

\subsubsection*{Correttezza del risultato}
Senza fallimenti, il sistema riesce a rispondere con un messaggio di
\emph{match} / \emph{fail} / \emph{dontknow} correttamente
per quanto definito nelle specifiche funzionali.
In generale, si garantisce che,
il sistema non dà falsi \emph{match} o falsi \emph{fail} della query:
viene ammessa solo la restituzione di un falso \emph{dontknow}.

Infatti,
in caso di fallimenti può accadere che il sistema, sebbene la somma
delle conoscenze parziali sia in grado di definire un risultato,
risponda comunque \emph{dontknow} all'utente.

Quando la conoscenza dei sensori aumenta,
non è garantito che le nuove informazioni possano essere immediatamente
utilizzate se queste sono state acquisite \emph{durante} la fase di verifica
di una query: anche in questo caso, il sistema può rispondere eventualmente
\emph{dontknow}, anche quando l'insieme (aggiornato) delle conoscenze parziali
dei sensori sarebbe in grado di dare una risposta più specifica.

%%%%%%%%%%%%%%%%%%%%
\end{document}
