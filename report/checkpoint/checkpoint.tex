\documentclass{llncs}

\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}
%% \usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage{blindtext}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{mathtools}
\usepackage{listings}
\usepackage[dvipsnames]{xcolor}
\usepackage[normalem]{ulem}
\usepackage{listings}
\usepackage[export]{adjustbox}
\usepackage{lscape}
\usepackage{float}
\usepackage{booktabs}

%% \usepackage{pdftricks}
%% \begin{psinputs}
%%   \usepackage{pstricks}
%% \end{psinputs}
%% \usepackage[pdf]{pstricks}

\usepackage{float}
\usepackage[hypertexnames=false]{hyperref}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\floatname{algorithm}{Pseudocode}

\usepackage{cleveref}
\usepackage{tikz}
\usetikzlibrary{matrix,shapes,arrows,positioning,chains}
\usepackage{hhline}
\usepackage{multirow}

\pagestyle{plain}

%%%%
\include{macro}
%%%%
\subtitle{A distribuited algorithm\\for the subgraph isomorphism problem}
\title{Analisi dei requisiti}
\author{Anna Becchi, Idriss Riouak}
\institute{Laurea Magistrale in Informatica\\Universit\`a di Udine, Italy}
\date{A.A. 2017/2018}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

%\begin{titlingpage}
\maketitle
\begin{abstract}
In letteratura il problema del \emph{subgraph isomorphism}
centralizzato è stato ampiamente studiato. Ciononostante è difficile
trovare studi relativi alla stessa problematica su sistemi distribuiti.
L'obiettivo della seguente analisi è fornire un algoritmo distribuito
per il \emph{subgraph isomorphism} individuandone le criticità e
problematiche, descrivendo dunque i requisiti funzionali e non
funzionali del sistema come ad esempio la \emph{tolleranza ai
guasti} e \emph{consistenza} delle strutture dati. 
\end{abstract}
%\end{titlingpage}

\section{Introduzione}
Il \emph{subgraph isomorphism} ha diverse applicazioni nello contesto
dei sistemi distribuiti, in particolare considereremo il caso in cui  un insieme
di \emph{robot} con \emph{sensori wireless} viene posizionato all'interno di
un edificio in maniera casuale. Tali robot hanno una visione parziale dell'edificio
e sono in grado di comunicare unicamente attraverso scambio di messaggi.
Dunque dato un percorso l'obiettivo finale è quello di determinare se esiste
solamente attraverso la conoscenza parziale dei robot.

\subsection{Modellazione del problema}
Dato un grafo $\cG = ( \Vset, E)$, $\Vset = \{v_i\}_{i \in V}$,
che rappresenta la mappa di un edificio, viene inizializzato un
insieme di processi $\Sset = \{s_i \}_{i \in S}$ con $S$ insieme
random $S \sseq V$.
Tali processi simulano l'insieme dei robot che
acquisiscono, durante la fase di inizializzazione, una conoscenza
parziale del luogo. L'acquisizione di nuova conoscenza corrisponde
alla memorizzazione in ogni $s_i$ della lista di adiacenza del nodo
corrispondente $v_i \in \Vset$.
Inizialmente dunque il raggio di conoscenza di ogni sensore corrisponde
a un solo arco del grafo.

Inoltre potrà essere simulato anche il loro spostamento e la progressiva
acquisizione di nuova conoscenza del grafo, compatibilmente con le
loro (limitate) capacità di memorizzazione.

L'algoritmo viene innescato da una query $\cQ = (\Vset_\cQ, E_\cQ)$, 
che viene divulgata alla rete di processi: l'obiettivo sarà verificare
nel grafo $\cG$ l'esistenza di un sottografo corrispondente a $\cQ$,
evitando di ricostruire la conoscenza totale e centralizzata del
grafo stesso.

Considereremo black-box tutti gli aspetti legati all'acquisizione delle informazioni 
da parte dei robot, focalizzando l'attenzione sull'astrazione matematica.

I vincoli sulle limitazioni fisiche dei sensori è lasciata all'utente finale dell'applicazione.
\subsection{Ambiente di sviluppo}
L'ambiente di sviluppo è stato scelto in modo tale da poter evidenziare solamente le caratteristiche più rilevanti del problema. Si è scelto di utilizzare il \emph{Akka}: un toolkit per la creazione di sistemi distribuiti che offre 


\begin{itemize}
\item applicabilità a modello fisico da cui traiamo ipotesi:
\item precisare che la nostra è un'astrazione -- uso di strumenti
  implementativi in grado di evidenziare solo le caratteristiche
  di rilevanza del problema: verrà fornita un'interfaccia strettamente
  legata alla ricerca del subgraph, focalizzando l'attenzione
  alle problematiche dei sistemi distribuiti.
  Verranno trattati black-box le modalità con cui i sensori
  acquisiscono informazioni sulla mappa, ragionando direttamente
  sull'astrazione matematica.
\item descrizione (formale) del problema
\end{itemize}

\coanote{Aggiunta no-brain di cose...}



\section{Requisiti funzionali}
\label{sec:func-req}
\begin{quote}
  Which functions must be offered to users / other programs?
  Which are the input data and the output data?
  Which is the expected effect?
\end{quote}

Si assume la memorizzazione pregressa di un grafo.
Questo potrà essere letto da un file esterno e caricato dal sistema
staticamente. Non sarà dunque possibile cambiare a runtime la mappa
del luogo nel quale i sensori lavorano.
\coanote{TODO: definire dimensione massima grafo, caratteristiche
  di memorizzazione.}

L'utente può decidere in fase di inizializzazione del sistema con quanti
sensori popolare la mappa. Questi verranno distribuiti in modo casuale
ognuno in corrispondenza di un nodo del grafo: è ammesso che più
sensori condividano in un momento la stessa posizione
(i.e. non c'è conflitto sui nodi in cui sono posizionati).

\coanote{TODO: Decidere \textbf{COME CAZZO} viene inserita la query
  dall'utente: decidere se la query viene distribuita a tutti i sensori
  inizialmente e se sì come... broadcast? messaggio a tutti i sensori
  (con tell in un ciclo sequenziale)?
  coda a cui tutti sono registrati?}

Se la query non viene trovata, l'utente può decidere se ritentare
la stessa ricerca dopo aver fatto acquisire nuova conoscenza al sistema
distribuito: ciò può essere fatto in due modi.
Si può aggiungere un nuovo sensore alla rete, posizionato in modo
casuale nel grafo. Alternativamente
si possono far muovere \emph{tutti} i sensori in un loro nodo adiacente,
scelto non deterministicamente, caricando dal grafo (centralizzato)
la lista di adiacenza del nuovo nodo: ciò simula quindi una fase di
\emph{apprendimento} da parte di ogni sensore. Occorre tenere presente
che i sensori hanno una capacità limitata di memorizzazione,
dunque si permetterà di mantenere contemporaneamente in memoria un
numero limitato di nodi: può dunque accadere che durante il movimento
vengano scordate le liste di adiacenza dei nodi più lontani.
\coanote{TODO: definire capacità massima.}\\

In caso in cui venga trovato un sottografo corrispondente alla query,
questo viene comunicato all'utente.
Oltre alla mera conferma della sua esistenza, vengono aggiunte
le eventuali istanziazioni dei nodi non etichettati.
Sebbene la stessa soluzione possa essere trovata da più sensori,
la sua restituzione sarà unica, in particoalre si eviterà di rispondere
positivamente più volte per confermare l'esistenza di un sottografo
interamente etichettato.\\

\coanote{TODO: definire già interfacce e nomi metodi??
  Almeno fornire sottoforma di elendo il nome del metodo, senza ancora
  specificare parametri e tipo parametri...
}

\section{Requisiti non funzionali}
\label{sec:nonfunc-req}
\begin{quote}
  Everything about mode and transparencies:
  availability, mobility, security, fault tolerance, etc.
  Are there execution time bounds? Minimum data rates?

  If requested, specific platforms/languages/middlewares requirements
  for the implementation can be decided here.
  (E.g.: if the project is on a SOA, we may request that functions
  are offered via SOAP or RESTful services).
\end{quote}

%%%%%%%%%%%%%%%%%%%%
\end{document}
