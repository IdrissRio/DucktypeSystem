\documentclass{llncs}

\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}
%% \usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage{blindtext}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{mathtools}
\usepackage{listings}
\usepackage[dvipsnames]{xcolor}
\usepackage[normalem]{ulem}
\usepackage{listings}
\usepackage[export]{adjustbox}
\usepackage{lscape}
\usepackage{float}
\usepackage{booktabs}

%% \usepackage{pdftricks}
%% \begin{psinputs}
%%   \usepackage{pstricks}
%% \end{psinputs}
%% \usepackage[pdf]{pstricks}

\usepackage{float}
\usepackage[hypertexnames=false]{hyperref}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\floatname{algorithm}{Pseudocode}

\usepackage{cleveref}
\usepackage{tikz}
\usetikzlibrary{matrix,shapes,arrows,positioning,chains}
\usepackage{hhline}
\usepackage{multirow}

\pagestyle{plain}

%%%%
\include{macro}
%%%%
\subtitle{A distribuited algorithm\\for the subgraph isomorphism problem}
\title{ANALISI DEI REQUISITI}
\author{Anna Becchi, Idriss Riouak}
\institute{Laurea Magistrale in Informatica\\Universit\`a di Udine, Italy}
\date{A.A. 2017/2018}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\maketitle

\section{Introduzione}
Il \emph{subgraph isomorphism} ha diverse applicazioni nel contesto
dei sistemi distribuiti: in particolare considereremo il caso in cui un insieme
di \emph{robot} con \emph{sensori wireless} viene posizionato all'interno di
un edificio in maniera casuale. I robot hanno una visione parziale del luogo
e sono in grado di comunicare tra loro unicamente attraverso scambio di messaggi.
Dato un percorso, l'obiettivo finale è quello di determinare se questo esiste
nell'edificio sfruttando solamente la conoscenza parziale e frammentata dei robot.

\subsection{Modellazione del problema}
Dato un grafo $\cG = ( \Vset, E)$, $\Vset = \{v_i\}_{i \in V}$,
che rappresenta la mappa di un edificio, viene inizializzato un
insieme di processi $\Sset = \{s_i \}_{i \in S}$ con $S$ insieme
random $S \sseq V$.
Tali processi simulano l'insieme dei robot che
acquisiscono, durante la fase di inizializzazione, una conoscenza
parziale del luogo. L'acquisizione di nuova conoscenza corrisponde
alla memorizzazione in ogni $s_i$ della lista di adiacenza del nodo
corrispondente $v_i \in \Vset$.
Inizialmente dunque il raggio di conoscenza di ogni sensore corrisponde
a un solo arco del grafo.

Inoltre potrà essere simulato anche il loro spostamento e la progressiva
acquisizione di nuova conoscenza del grafo, compatibilmente con le
loro (limitate) capacità di memorizzazione.

L'algoritmo viene innescato da una query $\cQ = (\Vset_\cQ, E_\cQ)$
che viene divulgata alla rete di processi: si dovrà verificare
l'esistenza nel grafo $\cG$ di un sottografo corrispondente a $\cQ$,
evitando di ricostruire la conoscenza totale e centralizzata del
grafo stesso.

Considereremo black-box tutti gli aspetti legati all'acquisizione delle informazioni
da parte dei robot, focalizzando l'attenzione sull'astrazione matematica.
%
%
\subsection{Ambiente di sviluppo}
L'ambiente di sviluppo è stato scelto in modo da poter evidenziare solamente
le caratteristiche più rilevanti del problema.
Si è scelto di utilizzare \emph{Akka}, un toolkit per la creazione di applicazioni
distribuite e concorrenti con supporto alla \emph{fault-tollerance event-driven}.
Il toolkit è disponibile sia per il linguaggio imperativo \emph{Java} che per il
funzionale \emph{Scala}.

Akka si basa sulla figura degli \emph{Actor}: un Actor è un'astrazione che permette
al programmatore di focalizzare l'attenzione sugli obiettivi funzionali liberandolo
da alcune problematiche della programmazione
concorrente e distribuita tra cui gestione dei thread e creazioni di canali.
%
\subsection{Ipotesi sul sistema}
\label{sec:hypotesis}
Il sistema distribuito del quale stiamo fornendo la descrizione verrà progettato per funzionare
sotto determinate ipotesi:
\begin{itemize}
\item il grafo $\cG = ( \Vset, E)$ rappresentante la mappa dell'edificio viene fornito
  in fase di inizializzazione dall'utente in un
  file di testo che espone l'elenco dei nodi etichettati e la matrice di adiacenza;
\item il grafo  $\cQ = (\Vset_\cQ, E_\cQ)$, rappresentante la query viene fornito dall'utente
  a runtime in un formato analogo a quello di $\cG$;
\item ambedue i grafi $\cG$ e $\cQ$ sono etichettati; $\cQ$ è un sottografo di $\cG$ se e solo se
  $\Vset_\cQ \subseteq \Vset \wedge E_\cQ \subseteq E$;
  % \cap (\Vset_\cQ \times \Vset_\cQ)$;  \coanote{Perché il \cap??}
\item la topologia del grafo $\cG = ( \Vset, E)$ è costante nel tempo;
\item due o più robot possano trovarsi contemporaneamente sullo stesso nodo;
\item i robot hanno limitazioni fisiche di memorizzazione:
  dovendo tenere in memoria l'intera query $\cQ$, questa dovrà avere
  dimensioni limitate dalla loro capacità massima; inoltre,
  si tenga presente che, in caso di spostamento, si garantisce che i sensori
  possono tenere in memoria solo la conoscenza acquisita nello stato attuale e in quello
  precedente (i.e., al secondo spostamento si potrebbe perdere la conoscenza acquisita
  durante l'inizializzazione).
  Per un sensore risulta dunque impossibile ricostruire l'intero grafo $\cG$ nella sua completezza;
\item il robot ha una conoscenza parziale del grafo $\cG$, ma ha la conoscenza
  totale del nodo sulla quale viene posizionato, i.e. la sua lista d'adiacenza è completa;
  %% Ben detto cazzo!
% \item \coanote{Definire le ipotesi sulla grandezza del grafo $\cG$!}.
% non dovendo memorizzarlo davvero nell'applicazione concreta non ha senso imporre delle restrizioni...imho...
\end{itemize}
%
%
\section{Requisiti funzionali}
Nella seguente sezione verranno descritti i requisiti funzionali
dell'applicativo che si intende realizzare.

\subsection{Inizializzazione}
In fase di inizializzazione il sistema caricherà il grafo $\cG = ( \Vset, E)$ dal file
fornito dall'utente. Quest'ultimo dovrà fornire in input due interi:
\begin{itemize}
\item \texttt{num\_proc:} rappresentante la cardinalità dell'insieme $\Sset$, ovvero il numero di
robot distribuiti sulla mappa dell'edificio;
\item \texttt{num\_search\_group} (\emph{opzionale}): rappresentante
  il livello di replicazione del sistema~\footnote{\label{fn:searchgroup}
    L'uso e la necessità dei \texttt{search\_group} verranno descritti
    nella Sezione~\ref*{sec:nonfunc-req}.} Se non specificato viene posto uguale a $3$.
\end{itemize}

\subsection{Computazione}
\label{sec:computation}
La query viene distribuita ad un elemento per ogni \texttt{search\_group}~\textsuperscript{\ref{fn:searchgroup}}
che inizierà a cercare un match tra i grafi $\cG$ e $\cQ$. Ogni volta che viene trovato un isomorfismo
parziale tra la conoscenza del robot e la query, quest'ultima viene prima sfoltita, rimuovendo
le informazioni già verificate, e poi inoltrata ad
un altro elemento dello stesso \texttt{search\_group}.

Se l'esisto della computazione della query dovesse condurre a un \texttt{DONTKNOW}
l'utente può decidere se ritentare la stessa ricerca facendo acquisire nuova conoscenza
all'intero sistema distribuito. Ciò può avvenire attraverso due modalità:
\begin{itemize}
	\item posizionare un nuovo robot all'interno del grafo $\cG$;
	\item muovere \emph{tutti} i robot in un nodo a loro adiacente, caricando e memorizzando
	  dal grafo $\cG$ la nuova matrice d'adiacenza.
          Come già analizzato in~\ref{sec:hypotesis},
          occorre tenere presente che i sensori hanno
	una capacità di memorizzazione limitata e dunque può accadere che durante
	tale operazione vengano sovrascritte le conoscenze relative ai nodi più lontani.
\end{itemize}

\subsection{Esito della computazione}
L'esito della computazione dell'algoritmo verrà comunicato a video all'utente finale.
I risultati previsti sono:
\begin{itemize}
\item \texttt{MATCH}: nel caso in cui, unicamente attraverso scambio di messaggi,
i sensori riuscissero a trovare un isomorfismo parziale tra il grafo $\cG$ e il grafo $\cQ$.
Ciò potrà avvenire soltanto se la query risultasse essere contenuta nella somma delle conoscenze
parziali di tutti i robot.
\item \texttt{FAIL}: nel caso in cui vengano riscontrate inconsistenze tra la somma
  delle conoscenze parziali (ma localmente certe) dei sensori e la query;
\item \texttt{DONTKNOW}: nel caso in cui, data la mancanza di una visione
  totale del grafo, non si riuscisse a determinare in maniera effettiva l'esistenza della query.
\end{itemize}

\subsection{Entità robot}
Essendo i robot gli attori principali del problema,
nella seguente sezione specifichiamo il loro comportamento
al ricevere di determinati messaggi dall'ambiente circostante.

Come già detto nella Sezione~\ref{sec:computation},
durante la fase di inizializzazione i robot vengono distribuiti
in maniera casuale sul grafo $\cG$.
Attraverso dei sensori riescono ad avere una conoscenza parziale
del grafo, inoltre sono in grado di muoversi e di conseguenza
sono in grado di aumentare la loro conoscenza. Tutto ciò nei limiti
fisici decritti nella Sezione~\ref{sec:hypotesis}.

Da un'analisi ad alto livello è emerso che i messaggi scambiati con
gli altri attori saranno:
\begin{itemize}
	\item \texttt{try\_query}: al robot è giunta~\footnote{Si
	tenga presente che ad un processo possono arrivare tante query
	quanto è il valore \texttt{num\_search\_group}.} la query e prova
	a trovare una corrispondenza tra la sua conoscenza parziale e
	la query stessa. Passando da un processo all'altro, la query
	viene scremata degli archi per cui viene trovato un match.
	Se non rimane nulla da dover ancora verificare, il robot comunica la presenza dell'isomorfismo attraverso
	il messaggio \texttt{MATCH}.

	Se dovesse riscontrare un'inconsistenza tra la query e
	le sue informazioni, comunica il mismatch attraverso
	il messaggio \texttt{FAIL}.

	Nel caso in cui la conoscenza del robot non sia sufficiente a completare il controllo
	dalla query, allora quest'ultima viene inoltrata ad un altro nodo.

	Al termine dell'elaborazione, il robot si dichiarerà non più interessato
	a seguire gli sviluppi di \emph{quella} query, avendo già contribuito con la
	sua conoscenza;
	\item \texttt{move:} causa lo spostamento del robot in uno dei
	nodi adiacenti, avendo come conseguenza il caricamento
	di nuova conoscenza.
\end{itemize}

\subsection{Interfaccia con l'utente}
Infine all'utente verrà fornito come punto d'accesso all'applicativo
un'interfaccia da terminale, le cui funzionalità saranno:
\begin{itemize}
	\item possibilità di caricare manualmente il grafo $\cG$ fornendo il percorso
	del file sulla quale è memorizzato; tale
	funzionalità sarà utile soprattutto in fase di sperimentazione;
	\item iniziare una nuova query fornendo il path del
	file sul quale è memorizzata; si tenga presente che la query
	può essere riproposta ad ogni terminazione dell'algoritmo di
	matching, senza dover riavviare il sistema;
        %	\coanote{Dobbiamo decidere su chi fare il controllo per la dimensione massima ?}
        % io direi demoni dal naso se si sfora.. ma il controllo lo dovrebbe fare il sistema di inizializzazione...
	\item imporre l'avanzamento di tutti
	i robot;
	\item aggiungere manualmente un nuovo robot;
	\item visualizzazione a video dei risultati ottenuti.
\end{itemize}

\section{Requisiti non funzionali}
\label{sec:nonfunc-req}

In questa sezione analizziamo le caratteristiche non funzionali
che il sistema sarà in grado di offrire.

\subsection{Scalabilità e trasparenza}
I sensori costituiranno una rete peer-to-peer,
senza alcuna suddivisione di ruoli a priori: i ruoli centralizzati
sono definiti staticamente con il compito fissato di fornire un punto
di accesso al cluster in ingresso (proponendo una nuova query) e
in uscita (raccogliendo informazioni relative alla riuscita
o al fallimento della query).

Un fondamentale requisito è che
la \emph{conoscenza} del grafo complessivo sia totalmente distribuita:
data la sua potenziale grandezza
non viene ricostruita alcuna descrizione centralizzata di essa.
Il sistema deve essere dunque scalabile e flessibile:
si devono poter aggiungere nuovi sensori o far spostare
quelli già presenti nella rete, senza la necessità di riconfigurare nulla.
L'implementazione delle
comunicazioni tra i punti di accesso centrali al cluster e
tra gli elementi stessi del cluster, potrà
sfruttare le caratteristiche offerte da \emph{Akka}:
scala con il numero di sensori e
deve essere svincolata dal conoscere la loro posizione.
Il grado di \emph{location transparency} offerto deve dunque essere molto elevato.

La gestione della conoscenza del grafo deve poter
sfruttare la scalabilità del sistema: quando nuovi sensori vengono
aggiunti, o quando si muovono quelli già presenti, si acquisiscono
nuove informazioni che devono essere utilizzabili dalle query successive.

\subsection{Balancing}
La risoluzione del problema e la ricostruzione del sottografo
comporta intrinsecamente l'esplorazione progressiva e sequenziale
dei sensori che hanno informazioni rilevanti per la query.
Sono quindi le caratteristiche proprie del problema a impedire di
parallelizzare il lavoro nel sistema distribuito:
per ogni ricerca si avrà un solo nodo attivo alla volta.

La cifra dell'algoritmo distribuito sta dunque nella
condivisione di conoscenza, piuttosto che nella suddivisione del lavoro.
%% Inoltre,
%% il percorso di esplorazione della query, progressivamente snellita,
%% non influisce nella sua determinazione: una qualunque delle n! possibili
%% permutazioni -- qualunque sia l'ordine in cui la query attraversa i nodi --
%% trova la stessa soluzione, che richiede l'intervento SEQUENZIALE di
%% tutti i nodi che possono dire qualcosa sulla query stessa.
%% Dunque, dal punto di vista della correttezza dell'algoritmo,
%% a meno di failure, possiamo far procedere una sola query alla volta.

\subsection{Failure model}
Trattandosi di query potenzialmente molto lunghe da verificare,
da gestirsi in modo sequenziale su un numero potenzialmente alto di sensori,
siamo disposti ad aggiungere uno scambio di messaggi non direttamente
informativi per quanto riguarda la ricerca: l'obiettivo è essere in grado
in caso di fallimenti di recuperare la query parziale,
evitando di perdere il lavoro eseguito fino a quel momento.

Occorre infatti tenere in considerazione i fallimenti legati alla rete e i
fallimenti legati ai sensori stessi.

Per proteggersi dalla perdita di messaggi da parte di una rete inaffidabile,
all'invio della query durante la ricerca, il mittente aspetterà un messaggio
di \emph{acknowledgement}: questo comporta dover definire un timeout
di attesa massima prima di stabilire che il messaggio è andato perduto
(e dunque che è necessario rinviarlo).
Bisogna tenere presente che
tale soluzione espone a casi di duplice invio della stessa query,
quando è il messaggio di \emph{ack} ad essere perso dalla rete.

Per proteggersi da casi di fallimento e morte dei sensori,
si utilizzerà una strategia di supervisione \emph{one-to-one}
per cui ogni sensore avrà un supervisore in grado di riattivarlo.
La ricerca può essere intaccata da fallimenti di questo tipo
quando il sensore muore nel momento in cui sta elaborando
nuove ipotesi sulla query attiva.
Copiare una versione della query parziale nel supervisore del nodo,
limita la finestra temporale in cui può accadere questo fallimento
critico.
Possiamo ulteriormente proteggere il sistema facendo procedere
più query contemporaneamente (ognuna con il proprio \texttt{search\_group}),
in numero pari al parametro \texttt{num\_search\_group}
definito dall'utente (3 di default).
La ridondanza introdotta, come già discusso,
non può essere una forma di parallelizzazione del lavoro: avere
più ricerche attive nello stesso momento permette unicamente di
aumentare le possibilità che una di queste riesca ad esplorare
tutto lo spazio dei sensori senza incontrare i (già limitati)
fallimenti critici ai quali il sistema rimane soggetto.
%% Questi ultimi infatti, hanno nel caso pessimo l'effetto di
%% rendere la corrispondente ricerca inattiva: quando una delle versioni
%% arriva alla conclusione, sblocca quelle che eventualmente sono rimaste
%% bloccate in questo stato.

Nel malaugurato caso in cui tutte le ricerche incontrino
fallimenti critici, il sistema risulterà bloccato: pur non potendo
distinguere tale sospensione dalla fase di ricerca, si affida
la responsabilità all'utente di terminare la ricerca manualmente.

\subsection{Correttezza del risultato}
Senza fallimenti, il sistema deve riuscire a rispondere con un messaggio di
\texttt{MATCH} / \texttt{FAIL} / \texttt{DONTKNOW} correttamente
rispetto a quanto definito nelle specifiche funzionali.
In generale, si garantisce che,
il sistema non dà falsi \texttt{MATCH} o falsi \texttt{FAIL} della query:
viene ammessa solo la restituzione di un falso \texttt{DONTKNOW}.

Infatti,
in caso di fallimenti può accadere che il sistema, sebbene la somma
delle conoscenze parziali sia in grado di definire un risultato,
risponda comunque \texttt{DONTKNOW} all'utente.

Quando la conoscenza dei sensori aumenta,
non è garantito che le nuove informazioni possano essere immediatamente
utilizzate se queste sono state acquisite \emph{durante} la fase di verifica
di una query: anche in questo caso, il sistema può rispondere eventualmente
\texttt{DONTKNOW}, anche quando l'insieme (aggiornato) delle conoscenze parziali
dei sensori sarebbe in grado di dare una risposta più specifica.

%%%%%%%%%%%%%%%%%%%%
\end{document}
